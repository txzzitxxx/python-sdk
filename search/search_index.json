{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#mcp-server","title":"MCP Server","text":"<p>This is the MCP Server implementation in Python.</p> <p>It only contains the API Reference for the time being.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#mcp.ClientSession","title":"ClientSession","text":"<p>               Bases: <code>BaseSession[ClientRequest, ClientNotification, ClientResult, ServerRequest, ServerNotification]</code></p> Source code in <code>src/mcp/client/session.py</code> <pre><code>class ClientSession(\n    BaseSession[\n        types.ClientRequest,\n        types.ClientNotification,\n        types.ClientResult,\n        types.ServerRequest,\n        types.ServerNotification,\n    ]\n):\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        read_timeout_seconds: timedelta | None = None,\n        sampling_callback: SamplingFnT | None = None,\n        elicitation_callback: ElicitationFnT | None = None,\n        list_roots_callback: ListRootsFnT | None = None,\n        logging_callback: LoggingFnT | None = None,\n        message_handler: MessageHandlerFnT | None = None,\n        client_info: types.Implementation | None = None,\n    ) -&gt; None:\n        super().__init__(\n            read_stream,\n            write_stream,\n            types.ServerRequest,\n            types.ServerNotification,\n            read_timeout_seconds=read_timeout_seconds,\n        )\n        self._client_info = client_info or DEFAULT_CLIENT_INFO\n        self._sampling_callback = sampling_callback or _default_sampling_callback\n        self._elicitation_callback = elicitation_callback or _default_elicitation_callback\n        self._list_roots_callback = list_roots_callback or _default_list_roots_callback\n        self._logging_callback = logging_callback or _default_logging_callback\n        self._message_handler = message_handler or _default_message_handler\n        self._tool_output_schemas: dict[str, dict[str, Any] | None] = {}\n\n    async def initialize(self) -&gt; types.InitializeResult:\n        sampling = types.SamplingCapability() if self._sampling_callback is not _default_sampling_callback else None\n        elicitation = (\n            types.ElicitationCapability() if self._elicitation_callback is not _default_elicitation_callback else None\n        )\n        roots = (\n            # TODO: Should this be based on whether we\n            # _will_ send notifications, or only whether\n            # they're supported?\n            types.RootsCapability(listChanged=True)\n            if self._list_roots_callback is not _default_list_roots_callback\n            else None\n        )\n\n        result = await self.send_request(\n            types.ClientRequest(\n                types.InitializeRequest(\n                    params=types.InitializeRequestParams(\n                        protocolVersion=types.LATEST_PROTOCOL_VERSION,\n                        capabilities=types.ClientCapabilities(\n                            sampling=sampling,\n                            elicitation=elicitation,\n                            experimental=None,\n                            roots=roots,\n                        ),\n                        clientInfo=self._client_info,\n                    ),\n                )\n            ),\n            types.InitializeResult,\n        )\n\n        if result.protocolVersion not in SUPPORTED_PROTOCOL_VERSIONS:\n            raise RuntimeError(f\"Unsupported protocol version from the server: {result.protocolVersion}\")\n\n        await self.send_notification(types.ClientNotification(types.InitializedNotification()))\n\n        return result\n\n    async def send_ping(self) -&gt; types.EmptyResult:\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(types.PingRequest()),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ClientNotification(\n                types.ProgressNotification(\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                ),\n            )\n        )\n\n    async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n        \"\"\"Send a logging/setLevel request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.SetLevelRequest(\n                    params=types.SetLevelRequestParams(level=level),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def list_resources(self, cursor: str | None = None) -&gt; types.ListResourcesResult:\n        \"\"\"Send a resources/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListResourcesRequest(\n                    params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n                )\n            ),\n            types.ListResourcesResult,\n        )\n\n    async def list_resource_templates(self, cursor: str | None = None) -&gt; types.ListResourceTemplatesResult:\n        \"\"\"Send a resources/templates/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListResourceTemplatesRequest(\n                    params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n                )\n            ),\n            types.ListResourceTemplatesResult,\n        )\n\n    async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n        \"\"\"Send a resources/read request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ReadResourceRequest(\n                    params=types.ReadResourceRequestParams(uri=uri),\n                )\n            ),\n            types.ReadResourceResult,\n        )\n\n    async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/subscribe request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.SubscribeRequest(\n                    params=types.SubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n        \"\"\"Send a resources/unsubscribe request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.UnsubscribeRequest(\n                    params=types.UnsubscribeRequestParams(uri=uri),\n                )\n            ),\n            types.EmptyResult,\n        )\n\n    async def call_tool(\n        self,\n        name: str,\n        arguments: dict[str, Any] | None = None,\n        read_timeout_seconds: timedelta | None = None,\n        progress_callback: ProgressFnT | None = None,\n    ) -&gt; types.CallToolResult:\n        \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n        result = await self.send_request(\n            types.ClientRequest(\n                types.CallToolRequest(\n                    params=types.CallToolRequestParams(\n                        name=name,\n                        arguments=arguments,\n                    ),\n                )\n            ),\n            types.CallToolResult,\n            request_read_timeout_seconds=read_timeout_seconds,\n            progress_callback=progress_callback,\n        )\n\n        if not result.isError:\n            await self._validate_tool_result(name, result)\n\n        return result\n\n    async def _validate_tool_result(self, name: str, result: types.CallToolResult) -&gt; None:\n        \"\"\"Validate the structured content of a tool result against its output schema.\"\"\"\n        if name not in self._tool_output_schemas:\n            # refresh output schema cache\n            await self.list_tools()\n\n        output_schema = None\n        if name in self._tool_output_schemas:\n            output_schema = self._tool_output_schemas.get(name)\n        else:\n            logger.warning(f\"Tool {name} not listed by server, cannot validate any structured content\")\n\n        if output_schema is not None:\n            if result.structuredContent is None:\n                raise RuntimeError(f\"Tool {name} has an output schema but did not return structured content\")\n            try:\n                validate(result.structuredContent, output_schema)\n            except ValidationError as e:\n                raise RuntimeError(f\"Invalid structured content returned by tool {name}: {e}\")\n            except SchemaError as e:\n                raise RuntimeError(f\"Invalid schema for tool {name}: {e}\")\n\n    async def list_prompts(self, cursor: str | None = None) -&gt; types.ListPromptsResult:\n        \"\"\"Send a prompts/list request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.ListPromptsRequest(\n                    params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n                )\n            ),\n            types.ListPromptsResult,\n        )\n\n    async def get_prompt(self, name: str, arguments: dict[str, str] | None = None) -&gt; types.GetPromptResult:\n        \"\"\"Send a prompts/get request.\"\"\"\n        return await self.send_request(\n            types.ClientRequest(\n                types.GetPromptRequest(\n                    params=types.GetPromptRequestParams(name=name, arguments=arguments),\n                )\n            ),\n            types.GetPromptResult,\n        )\n\n    async def complete(\n        self,\n        ref: types.ResourceTemplateReference | types.PromptReference,\n        argument: dict[str, str],\n        context_arguments: dict[str, str] | None = None,\n    ) -&gt; types.CompleteResult:\n        \"\"\"Send a completion/complete request.\"\"\"\n        context = None\n        if context_arguments is not None:\n            context = types.CompletionContext(arguments=context_arguments)\n\n        return await self.send_request(\n            types.ClientRequest(\n                types.CompleteRequest(\n                    params=types.CompleteRequestParams(\n                        ref=ref,\n                        argument=types.CompletionArgument(**argument),\n                        context=context,\n                    ),\n                )\n            ),\n            types.CompleteResult,\n        )\n\n    async def list_tools(self, cursor: str | None = None) -&gt; types.ListToolsResult:\n        \"\"\"Send a tools/list request.\"\"\"\n        result = await self.send_request(\n            types.ClientRequest(\n                types.ListToolsRequest(\n                    params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n                )\n            ),\n            types.ListToolsResult,\n        )\n\n        # Cache tool output schemas for future validation\n        # Note: don't clear the cache, as we may be using a cursor\n        for tool in result.tools:\n            self._tool_output_schemas[tool.name] = tool.outputSchema\n\n        return result\n\n    async def send_roots_list_changed(self) -&gt; None:\n        \"\"\"Send a roots/list_changed notification.\"\"\"\n        await self.send_notification(types.ClientNotification(types.RootsListChangedNotification()))\n\n    async def _received_request(self, responder: RequestResponder[types.ServerRequest, types.ClientResult]) -&gt; None:\n        ctx = RequestContext[ClientSession, Any](\n            request_id=responder.request_id,\n            meta=responder.request_meta,\n            session=self,\n            lifespan_context=None,\n        )\n\n        match responder.request.root:\n            case types.CreateMessageRequest(params=params):\n                with responder:\n                    response = await self._sampling_callback(ctx, params)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.ElicitRequest(params=params):\n                with responder:\n                    response = await self._elicitation_callback(ctx, params)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.ListRootsRequest():\n                with responder:\n                    response = await self._list_roots_callback(ctx)\n                    client_response = ClientResponse.validate_python(response)\n                    await responder.respond(client_response)\n\n            case types.PingRequest():\n                with responder:\n                    return await responder.respond(types.ClientResult(root=types.EmptyResult()))\n\n    async def _handle_incoming(\n        self,\n        req: RequestResponder[types.ServerRequest, types.ClientResult] | types.ServerNotification | Exception,\n    ) -&gt; None:\n        \"\"\"Handle incoming messages by forwarding to the message handler.\"\"\"\n        await self._message_handler(req)\n\n    async def _received_notification(self, notification: types.ServerNotification) -&gt; None:\n        \"\"\"Handle notifications from the server.\"\"\"\n        # Process specific notification types\n        match notification.root:\n            case types.LoggingMessageNotification(params=params):\n                await self._logging_callback(params)\n            case _:\n                pass\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(types.PingRequest()),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ClientNotification(\n            types.ProgressNotification(\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            ),\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.set_logging_level","title":"set_logging_level  <code>async</code>","text":"<pre><code>set_logging_level(level: LoggingLevel) -&gt; EmptyResult\n</code></pre> <p>Send a logging/setLevel request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def set_logging_level(self, level: types.LoggingLevel) -&gt; types.EmptyResult:\n    \"\"\"Send a logging/setLevel request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.SetLevelRequest(\n                params=types.SetLevelRequestParams(level=level),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resources","title":"list_resources  <code>async</code>","text":"<pre><code>list_resources(\n    cursor: str | None = None,\n) -&gt; ListResourcesResult\n</code></pre> <p>Send a resources/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resources(self, cursor: str | None = None) -&gt; types.ListResourcesResult:\n    \"\"\"Send a resources/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListResourcesRequest(\n                params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n            )\n        ),\n        types.ListResourcesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_resource_templates","title":"list_resource_templates  <code>async</code>","text":"<pre><code>list_resource_templates(\n    cursor: str | None = None,\n) -&gt; ListResourceTemplatesResult\n</code></pre> <p>Send a resources/templates/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_resource_templates(self, cursor: str | None = None) -&gt; types.ListResourceTemplatesResult:\n    \"\"\"Send a resources/templates/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListResourceTemplatesRequest(\n                params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n            )\n        ),\n        types.ListResourceTemplatesResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.read_resource","title":"read_resource  <code>async</code>","text":"<pre><code>read_resource(uri: AnyUrl) -&gt; ReadResourceResult\n</code></pre> <p>Send a resources/read request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def read_resource(self, uri: AnyUrl) -&gt; types.ReadResourceResult:\n    \"\"\"Send a resources/read request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ReadResourceRequest(\n                params=types.ReadResourceRequestParams(uri=uri),\n            )\n        ),\n        types.ReadResourceResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.subscribe_resource","title":"subscribe_resource  <code>async</code>","text":"<pre><code>subscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/subscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def subscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/subscribe request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.SubscribeRequest(\n                params=types.SubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.unsubscribe_resource","title":"unsubscribe_resource  <code>async</code>","text":"<pre><code>unsubscribe_resource(uri: AnyUrl) -&gt; EmptyResult\n</code></pre> <p>Send a resources/unsubscribe request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def unsubscribe_resource(self, uri: AnyUrl) -&gt; types.EmptyResult:\n    \"\"\"Send a resources/unsubscribe request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.UnsubscribeRequest(\n                params=types.UnsubscribeRequestParams(uri=uri),\n            )\n        ),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; CallToolResult\n</code></pre> <p>Send a tools/call request with optional progress callback support.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def call_tool(\n    self,\n    name: str,\n    arguments: dict[str, Any] | None = None,\n    read_timeout_seconds: timedelta | None = None,\n    progress_callback: ProgressFnT | None = None,\n) -&gt; types.CallToolResult:\n    \"\"\"Send a tools/call request with optional progress callback support.\"\"\"\n\n    result = await self.send_request(\n        types.ClientRequest(\n            types.CallToolRequest(\n                params=types.CallToolRequestParams(\n                    name=name,\n                    arguments=arguments,\n                ),\n            )\n        ),\n        types.CallToolResult,\n        request_read_timeout_seconds=read_timeout_seconds,\n        progress_callback=progress_callback,\n    )\n\n    if not result.isError:\n        await self._validate_tool_result(name, result)\n\n    return result\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_prompts","title":"list_prompts  <code>async</code>","text":"<pre><code>list_prompts(\n    cursor: str | None = None,\n) -&gt; ListPromptsResult\n</code></pre> <p>Send a prompts/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_prompts(self, cursor: str | None = None) -&gt; types.ListPromptsResult:\n    \"\"\"Send a prompts/list request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.ListPromptsRequest(\n                params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n            )\n        ),\n        types.ListPromptsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.get_prompt","title":"get_prompt  <code>async</code>","text":"<pre><code>get_prompt(\n    name: str, arguments: dict[str, str] | None = None\n) -&gt; GetPromptResult\n</code></pre> <p>Send a prompts/get request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def get_prompt(self, name: str, arguments: dict[str, str] | None = None) -&gt; types.GetPromptResult:\n    \"\"\"Send a prompts/get request.\"\"\"\n    return await self.send_request(\n        types.ClientRequest(\n            types.GetPromptRequest(\n                params=types.GetPromptRequestParams(name=name, arguments=arguments),\n            )\n        ),\n        types.GetPromptResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.complete","title":"complete  <code>async</code>","text":"<pre><code>complete(\n    ref: ResourceTemplateReference | PromptReference,\n    argument: dict[str, str],\n    context_arguments: dict[str, str] | None = None,\n) -&gt; CompleteResult\n</code></pre> <p>Send a completion/complete request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def complete(\n    self,\n    ref: types.ResourceTemplateReference | types.PromptReference,\n    argument: dict[str, str],\n    context_arguments: dict[str, str] | None = None,\n) -&gt; types.CompleteResult:\n    \"\"\"Send a completion/complete request.\"\"\"\n    context = None\n    if context_arguments is not None:\n        context = types.CompletionContext(arguments=context_arguments)\n\n    return await self.send_request(\n        types.ClientRequest(\n            types.CompleteRequest(\n                params=types.CompleteRequestParams(\n                    ref=ref,\n                    argument=types.CompletionArgument(**argument),\n                    context=context,\n                ),\n            )\n        ),\n        types.CompleteResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ClientSession.list_tools","title":"list_tools  <code>async</code>","text":"<pre><code>list_tools(cursor: str | None = None) -&gt; ListToolsResult\n</code></pre> <p>Send a tools/list request.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def list_tools(self, cursor: str | None = None) -&gt; types.ListToolsResult:\n    \"\"\"Send a tools/list request.\"\"\"\n    result = await self.send_request(\n        types.ClientRequest(\n            types.ListToolsRequest(\n                params=types.PaginatedRequestParams(cursor=cursor) if cursor is not None else None,\n            )\n        ),\n        types.ListToolsResult,\n    )\n\n    # Cache tool output schemas for future validation\n    # Note: don't clear the cache, as we may be using a cursor\n    for tool in result.tools:\n        self._tool_output_schemas[tool.name] = tool.outputSchema\n\n    return result\n</code></pre>"},{"location":"api/#mcp.ClientSession.send_roots_list_changed","title":"send_roots_list_changed  <code>async</code>","text":"<pre><code>send_roots_list_changed() -&gt; None\n</code></pre> <p>Send a roots/list_changed notification.</p> Source code in <code>src/mcp/client/session.py</code> <pre><code>async def send_roots_list_changed(self) -&gt; None:\n    \"\"\"Send a roots/list_changed notification.\"\"\"\n    await self.send_notification(types.ClientNotification(types.RootsListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup","title":"ClientSessionGroup","text":"<p>Client for managing connections to multiple MCP servers.</p> <p>This class is responsible for encapsulating management of server connections. It aggregates tools, resources, and prompts from all connected servers.</p> <p>For auxiliary handlers, such as resource subscription, this is delegated to the client and can be accessed via the session.</p> Example Usage <p>name_fn = lambda name, server_info: f\"{(server_info.name)}_{name}\" async with ClientSessionGroup(component_name_hook=name_fn) as group:     for server_params in server_params:         await group.connect_to_server(server_param)     ...</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>class ClientSessionGroup:\n    \"\"\"Client for managing connections to multiple MCP servers.\n\n    This class is responsible for encapsulating management of server connections.\n    It aggregates tools, resources, and prompts from all connected servers.\n\n    For auxiliary handlers, such as resource subscription, this is delegated to\n    the client and can be accessed via the session.\n\n    Example Usage:\n        name_fn = lambda name, server_info: f\"{(server_info.name)}_{name}\"\n        async with ClientSessionGroup(component_name_hook=name_fn) as group:\n            for server_params in server_params:\n                await group.connect_to_server(server_param)\n            ...\n\n    \"\"\"\n\n    class _ComponentNames(BaseModel):\n        \"\"\"Used for reverse index to find components.\"\"\"\n\n        prompts: set[str] = set()\n        resources: set[str] = set()\n        tools: set[str] = set()\n\n    # Standard MCP components.\n    _prompts: dict[str, types.Prompt]\n    _resources: dict[str, types.Resource]\n    _tools: dict[str, types.Tool]\n\n    # Client-server connection management.\n    _sessions: dict[mcp.ClientSession, _ComponentNames]\n    _tool_to_session: dict[str, mcp.ClientSession]\n    _exit_stack: contextlib.AsyncExitStack\n    _session_exit_stacks: dict[mcp.ClientSession, contextlib.AsyncExitStack]\n\n    # Optional fn consuming (component_name, serverInfo) for custom names.\n    # This is provide a means to mitigate naming conflicts across servers.\n    # Example: (tool_name, serverInfo) =&gt; \"{result.serverInfo.name}.{tool_name}\"\n    _ComponentNameHook: TypeAlias = Callable[[str, types.Implementation], str]\n    _component_name_hook: _ComponentNameHook | None\n\n    def __init__(\n        self,\n        exit_stack: contextlib.AsyncExitStack | None = None,\n        component_name_hook: _ComponentNameHook | None = None,\n    ) -&gt; None:\n        \"\"\"Initializes the MCP client.\"\"\"\n\n        self._tools = {}\n        self._resources = {}\n        self._prompts = {}\n\n        self._sessions = {}\n        self._tool_to_session = {}\n        if exit_stack is None:\n            self._exit_stack = contextlib.AsyncExitStack()\n            self._owns_exit_stack = True\n        else:\n            self._exit_stack = exit_stack\n            self._owns_exit_stack = False\n        self._session_exit_stacks = {}\n        self._component_name_hook = component_name_hook\n\n    async def __aenter__(self) -&gt; Self:\n        # Enter the exit stack only if we created it ourselves\n        if self._owns_exit_stack:\n            await self._exit_stack.__aenter__()\n        return self\n\n    async def __aexit__(\n        self,\n        _exc_type: type[BaseException] | None,\n        _exc_val: BaseException | None,\n        _exc_tb: TracebackType | None,\n    ) -&gt; bool | None:\n        \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n        # Only close the main exit stack if we created it\n        if self._owns_exit_stack:\n            await self._exit_stack.aclose()\n\n        # Concurrently close session stacks.\n        async with anyio.create_task_group() as tg:\n            for exit_stack in self._session_exit_stacks.values():\n                tg.start_soon(exit_stack.aclose)\n\n    @property\n    def sessions(self) -&gt; list[mcp.ClientSession]:\n        \"\"\"Returns the list of sessions being managed.\"\"\"\n        return list(self._sessions.keys())\n\n    @property\n    def prompts(self) -&gt; dict[str, types.Prompt]:\n        \"\"\"Returns the prompts as a dictionary of names to prompts.\"\"\"\n        return self._prompts\n\n    @property\n    def resources(self) -&gt; dict[str, types.Resource]:\n        \"\"\"Returns the resources as a dictionary of names to resources.\"\"\"\n        return self._resources\n\n    @property\n    def tools(self) -&gt; dict[str, types.Tool]:\n        \"\"\"Returns the tools as a dictionary of names to tools.\"\"\"\n        return self._tools\n\n    async def call_tool(self, name: str, args: dict[str, Any]) -&gt; types.CallToolResult:\n        \"\"\"Executes a tool given its name and arguments.\"\"\"\n        session = self._tool_to_session[name]\n        session_tool_name = self.tools[name].name\n        return await session.call_tool(session_tool_name, args)\n\n    async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n        \"\"\"Disconnects from a single MCP server.\"\"\"\n\n        session_known_for_components = session in self._sessions\n        session_known_for_stack = session in self._session_exit_stacks\n\n        if not session_known_for_components and not session_known_for_stack:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=\"Provided session is not managed or already disconnected.\",\n                )\n            )\n\n        if session_known_for_components:\n            component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n            # Remove prompts associated with the session.\n            for name in component_names.prompts:\n                if name in self._prompts:\n                    del self._prompts[name]\n            # Remove resources associated with the session.\n            for name in component_names.resources:\n                if name in self._resources:\n                    del self._resources[name]\n            # Remove tools associated with the session.\n            for name in component_names.tools:\n                if name in self._tools:\n                    del self._tools[name]\n                if name in self._tool_to_session:\n                    del self._tool_to_session[name]\n\n        # Clean up the session's resources via its dedicated exit stack\n        if session_known_for_stack:\n            session_stack_to_close = self._session_exit_stacks.pop(session)\n            await session_stack_to_close.aclose()\n\n    async def connect_with_session(\n        self, server_info: types.Implementation, session: mcp.ClientSession\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        await self._aggregate_components(server_info, session)\n        return session\n\n    async def connect_to_server(\n        self,\n        server_params: ServerParameters,\n    ) -&gt; mcp.ClientSession:\n        \"\"\"Connects to a single MCP server.\"\"\"\n        server_info, session = await self._establish_session(server_params)\n        return await self.connect_with_session(server_info, session)\n\n    async def _establish_session(\n        self, server_params: ServerParameters\n    ) -&gt; tuple[types.Implementation, mcp.ClientSession]:\n        \"\"\"Establish a client session to an MCP server.\"\"\"\n\n        session_stack = contextlib.AsyncExitStack()\n        try:\n            # Create read and write streams that facilitate io with the server.\n            if isinstance(server_params, StdioServerParameters):\n                client = mcp.stdio_client(server_params)\n                read, write = await session_stack.enter_async_context(client)\n            elif isinstance(server_params, SseServerParameters):\n                client = sse_client(\n                    url=server_params.url,\n                    headers=server_params.headers,\n                    timeout=server_params.timeout,\n                    sse_read_timeout=server_params.sse_read_timeout,\n                )\n                read, write = await session_stack.enter_async_context(client)\n            else:\n                client = streamablehttp_client(\n                    url=server_params.url,\n                    headers=server_params.headers,\n                    timeout=server_params.timeout,\n                    sse_read_timeout=server_params.sse_read_timeout,\n                    terminate_on_close=server_params.terminate_on_close,\n                )\n                read, write, _ = await session_stack.enter_async_context(client)\n\n            session = await session_stack.enter_async_context(mcp.ClientSession(read, write))\n            result = await session.initialize()\n\n            # Session successfully initialized.\n            # Store its stack and register the stack with the main group stack.\n            self._session_exit_stacks[session] = session_stack\n            # session_stack itself becomes a resource managed by the\n            # main _exit_stack.\n            await self._exit_stack.enter_async_context(session_stack)\n\n            return result.serverInfo, session\n        except Exception:\n            # If anything during this setup fails, ensure the session-specific\n            # stack is closed.\n            await session_stack.aclose()\n            raise\n\n    async def _aggregate_components(self, server_info: types.Implementation, session: mcp.ClientSession) -&gt; None:\n        \"\"\"Aggregates prompts, resources, and tools from a given session.\"\"\"\n\n        # Create a reverse index so we can find all prompts, resources, and\n        # tools belonging to this session. Used for removing components from\n        # the session group via self.disconnect_from_server.\n        component_names = self._ComponentNames()\n\n        # Temporary components dicts. We do not want to modify the aggregate\n        # lists in case of an intermediate failure.\n        prompts_temp: dict[str, types.Prompt] = {}\n        resources_temp: dict[str, types.Resource] = {}\n        tools_temp: dict[str, types.Tool] = {}\n        tool_to_session_temp: dict[str, mcp.ClientSession] = {}\n\n        # Query the server for its prompts and aggregate to list.\n        try:\n            prompts = (await session.list_prompts()).prompts\n            for prompt in prompts:\n                name = self._component_name(prompt.name, server_info)\n                prompts_temp[name] = prompt\n                component_names.prompts.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch prompts: {err}\")\n\n        # Query the server for its resources and aggregate to list.\n        try:\n            resources = (await session.list_resources()).resources\n            for resource in resources:\n                name = self._component_name(resource.name, server_info)\n                resources_temp[name] = resource\n                component_names.resources.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch resources: {err}\")\n\n        # Query the server for its tools and aggregate to list.\n        try:\n            tools = (await session.list_tools()).tools\n            for tool in tools:\n                name = self._component_name(tool.name, server_info)\n                tools_temp[name] = tool\n                tool_to_session_temp[name] = session\n                component_names.tools.add(name)\n        except McpError as err:\n            logging.warning(f\"Could not fetch tools: {err}\")\n\n        # Clean up exit stack for session if we couldn't retrieve anything\n        # from the server.\n        if not any((prompts_temp, resources_temp, tools_temp)):\n            del self._session_exit_stacks[session]\n\n        # Check for duplicates.\n        matching_prompts = prompts_temp.keys() &amp; self._prompts.keys()\n        if matching_prompts:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_prompts} already exist in group prompts.\",\n                )\n            )\n        matching_resources = resources_temp.keys() &amp; self._resources.keys()\n        if matching_resources:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_resources} already exist in group resources.\",\n                )\n            )\n        matching_tools = tools_temp.keys() &amp; self._tools.keys()\n        if matching_tools:\n            raise McpError(\n                types.ErrorData(\n                    code=types.INVALID_PARAMS,\n                    message=f\"{matching_tools} already exist in group tools.\",\n                )\n            )\n\n        # Aggregate components.\n        self._sessions[session] = component_names\n        self._prompts.update(prompts_temp)\n        self._resources.update(resources_temp)\n        self._tools.update(tools_temp)\n        self._tool_to_session.update(tool_to_session_temp)\n\n    def _component_name(self, name: str, server_info: types.Implementation) -&gt; str:\n        if self._component_name_hook:\n            return self._component_name_hook(name, server_info)\n        return name\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__init__","title":"__init__","text":"<pre><code>__init__(\n    exit_stack: AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None\n</code></pre> <p>Initializes the MCP client.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>def __init__(\n    self,\n    exit_stack: contextlib.AsyncExitStack | None = None,\n    component_name_hook: _ComponentNameHook | None = None,\n) -&gt; None:\n    \"\"\"Initializes the MCP client.\"\"\"\n\n    self._tools = {}\n    self._resources = {}\n    self._prompts = {}\n\n    self._sessions = {}\n    self._tool_to_session = {}\n    if exit_stack is None:\n        self._exit_stack = contextlib.AsyncExitStack()\n        self._owns_exit_stack = True\n    else:\n        self._exit_stack = exit_stack\n        self._owns_exit_stack = False\n    self._session_exit_stacks = {}\n    self._component_name_hook = component_name_hook\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.__aexit__","title":"__aexit__  <code>async</code>","text":"<pre><code>__aexit__(\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None\n</code></pre> <p>Closes session exit stacks and main exit stack upon completion.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def __aexit__(\n    self,\n    _exc_type: type[BaseException] | None,\n    _exc_val: BaseException | None,\n    _exc_tb: TracebackType | None,\n) -&gt; bool | None:\n    \"\"\"Closes session exit stacks and main exit stack upon completion.\"\"\"\n\n    # Only close the main exit stack if we created it\n    if self._owns_exit_stack:\n        await self._exit_stack.aclose()\n\n    # Concurrently close session stacks.\n    async with anyio.create_task_group() as tg:\n        for exit_stack in self._session_exit_stacks.values():\n            tg.start_soon(exit_stack.aclose)\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.sessions","title":"sessions  <code>property</code>","text":"<pre><code>sessions: list[ClientSession]\n</code></pre> <p>Returns the list of sessions being managed.</p>"},{"location":"api/#mcp.ClientSessionGroup.prompts","title":"prompts  <code>property</code>","text":"<pre><code>prompts: dict[str, Prompt]\n</code></pre> <p>Returns the prompts as a dictionary of names to prompts.</p>"},{"location":"api/#mcp.ClientSessionGroup.resources","title":"resources  <code>property</code>","text":"<pre><code>resources: dict[str, Resource]\n</code></pre> <p>Returns the resources as a dictionary of names to resources.</p>"},{"location":"api/#mcp.ClientSessionGroup.tools","title":"tools  <code>property</code>","text":"<pre><code>tools: dict[str, Tool]\n</code></pre> <p>Returns the tools as a dictionary of names to tools.</p>"},{"location":"api/#mcp.ClientSessionGroup.call_tool","title":"call_tool  <code>async</code>","text":"<pre><code>call_tool(\n    name: str, args: dict[str, Any]\n) -&gt; CallToolResult\n</code></pre> <p>Executes a tool given its name and arguments.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def call_tool(self, name: str, args: dict[str, Any]) -&gt; types.CallToolResult:\n    \"\"\"Executes a tool given its name and arguments.\"\"\"\n    session = self._tool_to_session[name]\n    session_tool_name = self.tools[name].name\n    return await session.call_tool(session_tool_name, args)\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.disconnect_from_server","title":"disconnect_from_server  <code>async</code>","text":"<pre><code>disconnect_from_server(session: ClientSession) -&gt; None\n</code></pre> <p>Disconnects from a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def disconnect_from_server(self, session: mcp.ClientSession) -&gt; None:\n    \"\"\"Disconnects from a single MCP server.\"\"\"\n\n    session_known_for_components = session in self._sessions\n    session_known_for_stack = session in self._session_exit_stacks\n\n    if not session_known_for_components and not session_known_for_stack:\n        raise McpError(\n            types.ErrorData(\n                code=types.INVALID_PARAMS,\n                message=\"Provided session is not managed or already disconnected.\",\n            )\n        )\n\n    if session_known_for_components:\n        component_names = self._sessions.pop(session)  # Pop from _sessions tracking\n\n        # Remove prompts associated with the session.\n        for name in component_names.prompts:\n            if name in self._prompts:\n                del self._prompts[name]\n        # Remove resources associated with the session.\n        for name in component_names.resources:\n            if name in self._resources:\n                del self._resources[name]\n        # Remove tools associated with the session.\n        for name in component_names.tools:\n            if name in self._tools:\n                del self._tools[name]\n            if name in self._tool_to_session:\n                del self._tool_to_session[name]\n\n    # Clean up the session's resources via its dedicated exit stack\n    if session_known_for_stack:\n        session_stack_to_close = self._session_exit_stacks.pop(session)\n        await session_stack_to_close.aclose()\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_with_session","title":"connect_with_session  <code>async</code>","text":"<pre><code>connect_with_session(\n    server_info: Implementation, session: ClientSession\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_with_session(\n    self, server_info: types.Implementation, session: mcp.ClientSession\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    await self._aggregate_components(server_info, session)\n    return session\n</code></pre>"},{"location":"api/#mcp.ClientSessionGroup.connect_to_server","title":"connect_to_server  <code>async</code>","text":"<pre><code>connect_to_server(\n    server_params: ServerParameters,\n) -&gt; ClientSession\n</code></pre> <p>Connects to a single MCP server.</p> Source code in <code>src/mcp/client/session_group.py</code> <pre><code>async def connect_to_server(\n    self,\n    server_params: ServerParameters,\n) -&gt; mcp.ClientSession:\n    \"\"\"Connects to a single MCP server.\"\"\"\n    server_info, session = await self._establish_session(server_params)\n    return await self.connect_with_session(server_info, session)\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters","title":"StdioServerParameters","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>class StdioServerParameters(BaseModel):\n    command: str\n    \"\"\"The executable to run to start the server.\"\"\"\n\n    args: list[str] = Field(default_factory=list)\n    \"\"\"Command line arguments to pass to the executable.\"\"\"\n\n    env: dict[str, str] | None = None\n    \"\"\"\n    The environment to use when spawning the process.\n\n    If not specified, the result of get_default_environment() will be used.\n    \"\"\"\n\n    cwd: str | Path | None = None\n    \"\"\"The working directory to use when spawning the process.\"\"\"\n\n    encoding: str = \"utf-8\"\n    \"\"\"\n    The text encoding used when sending/receiving messages to the server\n\n    defaults to utf-8\n    \"\"\"\n\n    encoding_error_handler: Literal[\"strict\", \"ignore\", \"replace\"] = \"strict\"\n    \"\"\"\n    The text encoding error handler.\n\n    See https://docs.python.org/3/library/codecs.html#codec-base-classes for\n    explanations of possible values\n    \"\"\"\n</code></pre>"},{"location":"api/#mcp.StdioServerParameters.command","title":"command  <code>instance-attribute</code>","text":"<pre><code>command: str\n</code></pre> <p>The executable to run to start the server.</p>"},{"location":"api/#mcp.StdioServerParameters.args","title":"args  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>args: list[str] = Field(default_factory=list)\n</code></pre> <p>Command line arguments to pass to the executable.</p>"},{"location":"api/#mcp.StdioServerParameters.env","title":"env  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>env: dict[str, str] | None = None\n</code></pre> <p>The environment to use when spawning the process.</p> <p>If not specified, the result of get_default_environment() will be used.</p>"},{"location":"api/#mcp.StdioServerParameters.cwd","title":"cwd  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cwd: str | Path | None = None\n</code></pre> <p>The working directory to use when spawning the process.</p>"},{"location":"api/#mcp.StdioServerParameters.encoding","title":"encoding  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding: str = 'utf-8'\n</code></pre> <p>The text encoding used when sending/receiving messages to the server</p> <p>defaults to utf-8</p>"},{"location":"api/#mcp.StdioServerParameters.encoding_error_handler","title":"encoding_error_handler  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>encoding_error_handler: Literal[\n    \"strict\", \"ignore\", \"replace\"\n] = \"strict\"\n</code></pre> <p>The text encoding error handler.</p> <p>See https://docs.python.org/3/library/codecs.html#codec-base-classes for explanations of possible values</p>"},{"location":"api/#mcp.stdio_client","title":"stdio_client  <code>async</code>","text":"<pre><code>stdio_client(\n    server: StdioServerParameters, errlog: TextIO = stderr\n)\n</code></pre> <p>Client transport for stdio: this will connect to a server by spawning a process and communicating with it over stdin/stdout.</p> Source code in <code>src/mcp/client/stdio/__init__.py</code> <pre><code>@asynccontextmanager\nasync def stdio_client(server: StdioServerParameters, errlog: TextIO = sys.stderr):\n    \"\"\"\n    Client transport for stdio: this will connect to a server by spawning a\n    process and communicating with it over stdin/stdout.\n    \"\"\"\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    try:\n        command = _get_executable_command(server.command)\n\n        # Open process with stderr piped for capture\n        process = await _create_platform_compatible_process(\n            command=command,\n            args=server.args,\n            env=({**get_default_environment(), **server.env} if server.env is not None else get_default_environment()),\n            errlog=errlog,\n            cwd=server.cwd,\n        )\n    except OSError:\n        # Clean up streams if process creation fails\n        await read_stream.aclose()\n        await write_stream.aclose()\n        await read_stream_writer.aclose()\n        await write_stream_reader.aclose()\n        raise\n\n    async def stdout_reader():\n        assert process.stdout, \"Opened process is missing stdout\"\n\n        try:\n            async with read_stream_writer:\n                buffer = \"\"\n                async for chunk in TextReceiveStream(\n                    process.stdout,\n                    encoding=server.encoding,\n                    errors=server.encoding_error_handler,\n                ):\n                    lines = (buffer + chunk).split(\"\\n\")\n                    buffer = lines.pop()\n\n                    for line in lines:\n                        try:\n                            message = types.JSONRPCMessage.model_validate_json(line)\n                        except Exception as exc:\n                            await read_stream_writer.send(exc)\n                            continue\n\n                        session_message = SessionMessage(message)\n                        await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async def stdin_writer():\n        assert process.stdin, \"Opened process is missing stdin\"\n\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(by_alias=True, exclude_none=True)\n                    await process.stdin.send(\n                        (json + \"\\n\").encode(\n                            encoding=server.encoding,\n                            errors=server.encoding_error_handler,\n                        )\n                    )\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async with (\n        anyio.create_task_group() as tg,\n        process,\n    ):\n        tg.start_soon(stdout_reader)\n        tg.start_soon(stdin_writer)\n        try:\n            yield read_stream, write_stream\n        finally:\n            # MCP spec: stdio shutdown sequence\n            # 1. Close input stream to server\n            # 2. Wait for server to exit, or send SIGTERM if it doesn't exit in time\n            # 3. Send SIGKILL if still not exited\n            if process.stdin:\n                try:\n                    await process.stdin.aclose()\n                except Exception:\n                    # stdin might already be closed, which is fine\n                    pass\n\n            try:\n                # Give the process time to exit gracefully after stdin closes\n                with anyio.fail_after(PROCESS_TERMINATION_TIMEOUT):\n                    await process.wait()\n            except TimeoutError:\n                # Process didn't exit from stdin closure, use platform-specific termination\n                # which handles SIGTERM -&gt; SIGKILL escalation\n                await _terminate_process_tree(process)\n            except ProcessLookupError:\n                # Process already exited, which is fine\n                pass\n            await read_stream.aclose()\n            await write_stream.aclose()\n            await read_stream_writer.aclose()\n            await write_stream_reader.aclose()\n</code></pre>"},{"location":"api/#mcp.ServerSession","title":"ServerSession","text":"<p>               Bases: <code>BaseSession[ServerRequest, ServerNotification, ServerResult, ClientRequest, ClientNotification]</code></p> Source code in <code>src/mcp/server/session.py</code> <pre><code>class ServerSession(\n    BaseSession[\n        types.ServerRequest,\n        types.ServerNotification,\n        types.ServerResult,\n        types.ClientRequest,\n        types.ClientNotification,\n    ]\n):\n    _initialized: InitializationState = InitializationState.NotInitialized\n    _client_params: types.InitializeRequestParams | None = None\n\n    def __init__(\n        self,\n        read_stream: MemoryObjectReceiveStream[SessionMessage | Exception],\n        write_stream: MemoryObjectSendStream[SessionMessage],\n        init_options: InitializationOptions,\n        stateless: bool = False,\n    ) -&gt; None:\n        super().__init__(read_stream, write_stream, types.ClientRequest, types.ClientNotification)\n        self._initialization_state = (\n            InitializationState.Initialized if stateless else InitializationState.NotInitialized\n        )\n\n        self._init_options = init_options\n        self._incoming_message_stream_writer, self._incoming_message_stream_reader = anyio.create_memory_object_stream[\n            ServerRequestResponder\n        ](0)\n        self._exit_stack.push_async_callback(lambda: self._incoming_message_stream_reader.aclose())\n\n    @property\n    def client_params(self) -&gt; types.InitializeRequestParams | None:\n        return self._client_params\n\n    def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:\n        \"\"\"Check if the client supports a specific capability.\"\"\"\n        if self._client_params is None:\n            return False\n\n        # Get client capabilities from initialization params\n        client_caps = self._client_params.capabilities\n\n        # Check each specified capability in the passed in capability object\n        if capability.roots is not None:\n            if client_caps.roots is None:\n                return False\n            if capability.roots.listChanged and not client_caps.roots.listChanged:\n                return False\n\n        if capability.sampling is not None:\n            if client_caps.sampling is None:\n                return False\n\n        if capability.elicitation is not None:\n            if client_caps.elicitation is None:\n                return False\n\n        if capability.experimental is not None:\n            if client_caps.experimental is None:\n                return False\n            # Check each experimental capability\n            for exp_key, exp_value in capability.experimental.items():\n                if exp_key not in client_caps.experimental or client_caps.experimental[exp_key] != exp_value:\n                    return False\n\n        return True\n\n    async def _receive_loop(self) -&gt; None:\n        async with self._incoming_message_stream_writer:\n            await super()._receive_loop()\n\n    async def _received_request(self, responder: RequestResponder[types.ClientRequest, types.ServerResult]):\n        match responder.request.root:\n            case types.InitializeRequest(params=params):\n                requested_version = params.protocolVersion\n                self._initialization_state = InitializationState.Initializing\n                self._client_params = params\n                with responder:\n                    await responder.respond(\n                        types.ServerResult(\n                            types.InitializeResult(\n                                protocolVersion=requested_version\n                                if requested_version in SUPPORTED_PROTOCOL_VERSIONS\n                                else types.LATEST_PROTOCOL_VERSION,\n                                capabilities=self._init_options.capabilities,\n                                serverInfo=types.Implementation(\n                                    name=self._init_options.server_name,\n                                    version=self._init_options.server_version,\n                                ),\n                                instructions=self._init_options.instructions,\n                            )\n                        )\n                    )\n            case types.PingRequest():\n                # Ping requests are allowed at any time\n                pass\n            case _:\n                if self._initialization_state != InitializationState.Initialized:\n                    raise RuntimeError(\"Received request before initialization was complete\")\n\n    async def _received_notification(self, notification: types.ClientNotification) -&gt; None:\n        # Need this to avoid ASYNC910\n        await anyio.lowlevel.checkpoint()\n        match notification.root:\n            case types.InitializedNotification():\n                self._initialization_state = InitializationState.Initialized\n            case _:\n                if self._initialization_state != InitializationState.Initialized:\n                    raise RuntimeError(\"Received notification before initialization was complete\")\n\n    async def send_log_message(\n        self,\n        level: types.LoggingLevel,\n        data: Any,\n        logger: str | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; None:\n        \"\"\"Send a log message notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.LoggingMessageNotification(\n                    params=types.LoggingMessageNotificationParams(\n                        level=level,\n                        data=data,\n                        logger=logger,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_updated(self, uri: AnyUrl) -&gt; None:\n        \"\"\"Send a resource updated notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ResourceUpdatedNotification(\n                    params=types.ResourceUpdatedNotificationParams(uri=uri),\n                )\n            )\n        )\n\n    async def create_message(\n        self,\n        messages: list[types.SamplingMessage],\n        *,\n        max_tokens: int,\n        system_prompt: str | None = None,\n        include_context: types.IncludeContext | None = None,\n        temperature: float | None = None,\n        stop_sequences: list[str] | None = None,\n        metadata: dict[str, Any] | None = None,\n        model_preferences: types.ModelPreferences | None = None,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.CreateMessageResult:\n        \"\"\"Send a sampling/create_message request.\"\"\"\n        return await self.send_request(\n            request=types.ServerRequest(\n                types.CreateMessageRequest(\n                    params=types.CreateMessageRequestParams(\n                        messages=messages,\n                        systemPrompt=system_prompt,\n                        includeContext=include_context,\n                        temperature=temperature,\n                        maxTokens=max_tokens,\n                        stopSequences=stop_sequences,\n                        metadata=metadata,\n                        modelPreferences=model_preferences,\n                    ),\n                )\n            ),\n            result_type=types.CreateMessageResult,\n            metadata=ServerMessageMetadata(\n                related_request_id=related_request_id,\n            ),\n        )\n\n    async def list_roots(self) -&gt; types.ListRootsResult:\n        \"\"\"Send a roots/list request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(types.ListRootsRequest()),\n            types.ListRootsResult,\n        )\n\n    async def elicit(\n        self,\n        message: str,\n        requestedSchema: types.ElicitRequestedSchema,\n        related_request_id: types.RequestId | None = None,\n    ) -&gt; types.ElicitResult:\n        \"\"\"Send an elicitation/create request.\n\n        Args:\n            message: The message to present to the user\n            requestedSchema: Schema defining the expected response structure\n\n        Returns:\n            The client's response\n        \"\"\"\n        return await self.send_request(\n            types.ServerRequest(\n                types.ElicitRequest(\n                    params=types.ElicitRequestParams(\n                        message=message,\n                        requestedSchema=requestedSchema,\n                    ),\n                )\n            ),\n            types.ElicitResult,\n            metadata=ServerMessageMetadata(related_request_id=related_request_id),\n        )\n\n    async def send_ping(self) -&gt; types.EmptyResult:\n        \"\"\"Send a ping request.\"\"\"\n        return await self.send_request(\n            types.ServerRequest(types.PingRequest()),\n            types.EmptyResult,\n        )\n\n    async def send_progress_notification(\n        self,\n        progress_token: str | int,\n        progress: float,\n        total: float | None = None,\n        message: str | None = None,\n        related_request_id: str | None = None,\n    ) -&gt; None:\n        \"\"\"Send a progress notification.\"\"\"\n        await self.send_notification(\n            types.ServerNotification(\n                types.ProgressNotification(\n                    params=types.ProgressNotificationParams(\n                        progressToken=progress_token,\n                        progress=progress,\n                        total=total,\n                        message=message,\n                    ),\n                )\n            ),\n            related_request_id,\n        )\n\n    async def send_resource_list_changed(self) -&gt; None:\n        \"\"\"Send a resource list changed notification.\"\"\"\n        await self.send_notification(types.ServerNotification(types.ResourceListChangedNotification()))\n\n    async def send_tool_list_changed(self) -&gt; None:\n        \"\"\"Send a tool list changed notification.\"\"\"\n        await self.send_notification(types.ServerNotification(types.ToolListChangedNotification()))\n\n    async def send_prompt_list_changed(self) -&gt; None:\n        \"\"\"Send a prompt list changed notification.\"\"\"\n        await self.send_notification(types.ServerNotification(types.PromptListChangedNotification()))\n\n    async def _handle_incoming(self, req: ServerRequestResponder) -&gt; None:\n        await self._incoming_message_stream_writer.send(req)\n\n    @property\n    def incoming_messages(\n        self,\n    ) -&gt; MemoryObjectReceiveStream[ServerRequestResponder]:\n        return self._incoming_message_stream_reader\n</code></pre>"},{"location":"api/#mcp.ServerSession.check_client_capability","title":"check_client_capability","text":"<pre><code>check_client_capability(\n    capability: ClientCapabilities,\n) -&gt; bool\n</code></pre> <p>Check if the client supports a specific capability.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>def check_client_capability(self, capability: types.ClientCapabilities) -&gt; bool:\n    \"\"\"Check if the client supports a specific capability.\"\"\"\n    if self._client_params is None:\n        return False\n\n    # Get client capabilities from initialization params\n    client_caps = self._client_params.capabilities\n\n    # Check each specified capability in the passed in capability object\n    if capability.roots is not None:\n        if client_caps.roots is None:\n            return False\n        if capability.roots.listChanged and not client_caps.roots.listChanged:\n            return False\n\n    if capability.sampling is not None:\n        if client_caps.sampling is None:\n            return False\n\n    if capability.elicitation is not None:\n        if client_caps.elicitation is None:\n            return False\n\n    if capability.experimental is not None:\n        if client_caps.experimental is None:\n            return False\n        # Check each experimental capability\n        for exp_key, exp_value in capability.experimental.items():\n            if exp_key not in client_caps.experimental or client_caps.experimental[exp_key] != exp_value:\n                return False\n\n    return True\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_log_message","title":"send_log_message  <code>async</code>","text":"<pre><code>send_log_message(\n    level: LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: RequestId | None = None,\n) -&gt; None\n</code></pre> <p>Send a log message notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_log_message(\n    self,\n    level: types.LoggingLevel,\n    data: Any,\n    logger: str | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; None:\n    \"\"\"Send a log message notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.LoggingMessageNotification(\n                params=types.LoggingMessageNotificationParams(\n                    level=level,\n                    data=data,\n                    logger=logger,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_updated","title":"send_resource_updated  <code>async</code>","text":"<pre><code>send_resource_updated(uri: AnyUrl) -&gt; None\n</code></pre> <p>Send a resource updated notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_updated(self, uri: AnyUrl) -&gt; None:\n    \"\"\"Send a resource updated notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ResourceUpdatedNotification(\n                params=types.ResourceUpdatedNotificationParams(uri=uri),\n            )\n        )\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.create_message","title":"create_message  <code>async</code>","text":"<pre><code>create_message(\n    messages: list[SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: ModelPreferences | None = None,\n    related_request_id: RequestId | None = None\n) -&gt; CreateMessageResult\n</code></pre> <p>Send a sampling/create_message request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def create_message(\n    self,\n    messages: list[types.SamplingMessage],\n    *,\n    max_tokens: int,\n    system_prompt: str | None = None,\n    include_context: types.IncludeContext | None = None,\n    temperature: float | None = None,\n    stop_sequences: list[str] | None = None,\n    metadata: dict[str, Any] | None = None,\n    model_preferences: types.ModelPreferences | None = None,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.CreateMessageResult:\n    \"\"\"Send a sampling/create_message request.\"\"\"\n    return await self.send_request(\n        request=types.ServerRequest(\n            types.CreateMessageRequest(\n                params=types.CreateMessageRequestParams(\n                    messages=messages,\n                    systemPrompt=system_prompt,\n                    includeContext=include_context,\n                    temperature=temperature,\n                    maxTokens=max_tokens,\n                    stopSequences=stop_sequences,\n                    metadata=metadata,\n                    modelPreferences=model_preferences,\n                ),\n            )\n        ),\n        result_type=types.CreateMessageResult,\n        metadata=ServerMessageMetadata(\n            related_request_id=related_request_id,\n        ),\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.list_roots","title":"list_roots  <code>async</code>","text":"<pre><code>list_roots() -&gt; ListRootsResult\n</code></pre> <p>Send a roots/list request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def list_roots(self) -&gt; types.ListRootsResult:\n    \"\"\"Send a roots/list request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(types.ListRootsRequest()),\n        types.ListRootsResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.elicit","title":"elicit  <code>async</code>","text":"<pre><code>elicit(\n    message: str,\n    requestedSchema: ElicitRequestedSchema,\n    related_request_id: RequestId | None = None,\n) -&gt; ElicitResult\n</code></pre> <p>Send an elicitation/create request.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to present to the user</p> required <code>requestedSchema</code> <code>ElicitRequestedSchema</code> <p>Schema defining the expected response structure</p> required <p>Returns:</p> Type Description <code>ElicitResult</code> <p>The client's response</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def elicit(\n    self,\n    message: str,\n    requestedSchema: types.ElicitRequestedSchema,\n    related_request_id: types.RequestId | None = None,\n) -&gt; types.ElicitResult:\n    \"\"\"Send an elicitation/create request.\n\n    Args:\n        message: The message to present to the user\n        requestedSchema: Schema defining the expected response structure\n\n    Returns:\n        The client's response\n    \"\"\"\n    return await self.send_request(\n        types.ServerRequest(\n            types.ElicitRequest(\n                params=types.ElicitRequestParams(\n                    message=message,\n                    requestedSchema=requestedSchema,\n                ),\n            )\n        ),\n        types.ElicitResult,\n        metadata=ServerMessageMetadata(related_request_id=related_request_id),\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_ping","title":"send_ping  <code>async</code>","text":"<pre><code>send_ping() -&gt; EmptyResult\n</code></pre> <p>Send a ping request.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_ping(self) -&gt; types.EmptyResult:\n    \"\"\"Send a ping request.\"\"\"\n    return await self.send_request(\n        types.ServerRequest(types.PingRequest()),\n        types.EmptyResult,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_progress_notification","title":"send_progress_notification  <code>async</code>","text":"<pre><code>send_progress_notification(\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None\n</code></pre> <p>Send a progress notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_progress_notification(\n    self,\n    progress_token: str | int,\n    progress: float,\n    total: float | None = None,\n    message: str | None = None,\n    related_request_id: str | None = None,\n) -&gt; None:\n    \"\"\"Send a progress notification.\"\"\"\n    await self.send_notification(\n        types.ServerNotification(\n            types.ProgressNotification(\n                params=types.ProgressNotificationParams(\n                    progressToken=progress_token,\n                    progress=progress,\n                    total=total,\n                    message=message,\n                ),\n            )\n        ),\n        related_request_id,\n    )\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_resource_list_changed","title":"send_resource_list_changed  <code>async</code>","text":"<pre><code>send_resource_list_changed() -&gt; None\n</code></pre> <p>Send a resource list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_resource_list_changed(self) -&gt; None:\n    \"\"\"Send a resource list changed notification.\"\"\"\n    await self.send_notification(types.ServerNotification(types.ResourceListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_tool_list_changed","title":"send_tool_list_changed  <code>async</code>","text":"<pre><code>send_tool_list_changed() -&gt; None\n</code></pre> <p>Send a tool list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_tool_list_changed(self) -&gt; None:\n    \"\"\"Send a tool list changed notification.\"\"\"\n    await self.send_notification(types.ServerNotification(types.ToolListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.ServerSession.send_prompt_list_changed","title":"send_prompt_list_changed  <code>async</code>","text":"<pre><code>send_prompt_list_changed() -&gt; None\n</code></pre> <p>Send a prompt list changed notification.</p> Source code in <code>src/mcp/server/session.py</code> <pre><code>async def send_prompt_list_changed(self) -&gt; None:\n    \"\"\"Send a prompt list changed notification.\"\"\"\n    await self.send_notification(types.ServerNotification(types.PromptListChangedNotification()))\n</code></pre>"},{"location":"api/#mcp.stdio_server","title":"stdio_server  <code>async</code>","text":"<pre><code>stdio_server(\n    stdin: AsyncFile[str] | None = None,\n    stdout: AsyncFile[str] | None = None,\n)\n</code></pre> <p>Server transport for stdio: this communicates with an MCP client by reading from the current process' stdin and writing to stdout.</p> Source code in <code>src/mcp/server/stdio.py</code> <pre><code>@asynccontextmanager\nasync def stdio_server(\n    stdin: anyio.AsyncFile[str] | None = None,\n    stdout: anyio.AsyncFile[str] | None = None,\n):\n    \"\"\"\n    Server transport for stdio: this communicates with an MCP client by reading\n    from the current process' stdin and writing to stdout.\n    \"\"\"\n    # Purposely not using context managers for these, as we don't want to close\n    # standard process handles. Encoding of stdin/stdout as text streams on\n    # python is platform-dependent (Windows is particularly problematic), so we\n    # re-wrap the underlying binary stream to ensure UTF-8.\n    if not stdin:\n        stdin = anyio.wrap_file(TextIOWrapper(sys.stdin.buffer, encoding=\"utf-8\"))\n    if not stdout:\n        stdout = anyio.wrap_file(TextIOWrapper(sys.stdout.buffer, encoding=\"utf-8\"))\n\n    read_stream: MemoryObjectReceiveStream[SessionMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[SessionMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[SessionMessage]\n    write_stream_reader: MemoryObjectReceiveStream[SessionMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    async def stdin_reader():\n        try:\n            async with read_stream_writer:\n                async for line in stdin:\n                    try:\n                        message = types.JSONRPCMessage.model_validate_json(line)\n                    except Exception as exc:\n                        await read_stream_writer.send(exc)\n                        continue\n\n                    session_message = SessionMessage(message)\n                    await read_stream_writer.send(session_message)\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async def stdout_writer():\n        try:\n            async with write_stream_reader:\n                async for session_message in write_stream_reader:\n                    json = session_message.message.model_dump_json(by_alias=True, exclude_none=True)\n                    await stdout.write(json + \"\\n\")\n                    await stdout.flush()\n        except anyio.ClosedResourceError:\n            await anyio.lowlevel.checkpoint()\n\n    async with anyio.create_task_group() as tg:\n        tg.start_soon(stdin_reader)\n        tg.start_soon(stdout_writer)\n        yield read_stream, write_stream\n</code></pre>"},{"location":"api/#mcp.McpError","title":"McpError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception type raised when an error arrives over an MCP connection.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>class McpError(Exception):\n    \"\"\"\n    Exception type raised when an error arrives over an MCP connection.\n    \"\"\"\n\n    error: ErrorData\n\n    def __init__(self, error: ErrorData):\n        \"\"\"Initialize McpError.\"\"\"\n        super().__init__(error.message)\n        self.error = error\n</code></pre>"},{"location":"api/#mcp.McpError.__init__","title":"__init__","text":"<pre><code>__init__(error: ErrorData)\n</code></pre> <p>Initialize McpError.</p> Source code in <code>src/mcp/shared/exceptions.py</code> <pre><code>def __init__(self, error: ErrorData):\n    \"\"\"Initialize McpError.\"\"\"\n    super().__init__(error.message)\n    self.error = error\n</code></pre>"},{"location":"api/#mcp.CallToolRequest","title":"CallToolRequest","text":"<p>               Bases: <code>Request[CallToolRequestParams, Literal['tools/call']]</code></p> <p>Used by the client to invoke a tool provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CallToolRequest(Request[CallToolRequestParams, Literal[\"tools/call\"]]):\n    \"\"\"Used by the client to invoke a tool provided by the server.\"\"\"\n\n    method: Literal[\"tools/call\"] = \"tools/call\"\n    params: CallToolRequestParams\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities","title":"ClientCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities a client may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ClientCapabilities(BaseModel):\n    \"\"\"Capabilities a client may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the client supports.\"\"\"\n    sampling: SamplingCapability | None = None\n    \"\"\"Present if the client supports sampling from an LLM.\"\"\"\n    elicitation: ElicitationCapability | None = None\n    \"\"\"Present if the client supports elicitation from the user.\"\"\"\n    roots: RootsCapability | None = None\n    \"\"\"Present if the client supports listing roots.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ClientCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the client supports.</p>"},{"location":"api/#mcp.ClientCapabilities.sampling","title":"sampling  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sampling: SamplingCapability | None = None\n</code></pre> <p>Present if the client supports sampling from an LLM.</p>"},{"location":"api/#mcp.ClientCapabilities.elicitation","title":"elicitation  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>elicitation: ElicitationCapability | None = None\n</code></pre> <p>Present if the client supports elicitation from the user.</p>"},{"location":"api/#mcp.ClientCapabilities.roots","title":"roots  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>roots: RootsCapability | None = None\n</code></pre> <p>Present if the client supports listing roots.</p>"},{"location":"api/#mcp.CompleteRequest","title":"CompleteRequest","text":"<p>               Bases: <code>Request[CompleteRequestParams, Literal['completion/complete']]</code></p> <p>A request from the client to the server, to ask for completion options.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CompleteRequest(Request[CompleteRequestParams, Literal[\"completion/complete\"]]):\n    \"\"\"A request from the client to the server, to ask for completion options.\"\"\"\n\n    method: Literal[\"completion/complete\"] = \"completion/complete\"\n    params: CompleteRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageRequest","title":"CreateMessageRequest","text":"<p>               Bases: <code>Request[CreateMessageRequestParams, Literal['sampling/createMessage']]</code></p> <p>A request from the server to sample an LLM via the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageRequest(Request[CreateMessageRequestParams, Literal[\"sampling/createMessage\"]]):\n    \"\"\"A request from the server to sample an LLM via the client.\"\"\"\n\n    method: Literal[\"sampling/createMessage\"] = \"sampling/createMessage\"\n    params: CreateMessageRequestParams\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult","title":"CreateMessageResult","text":"<p>               Bases: <code>Result</code></p> <p>The client's response to a sampling/create_message request from the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class CreateMessageResult(Result):\n    \"\"\"The client's response to a sampling/create_message request from the server.\"\"\"\n\n    role: Role\n    content: TextContent | ImageContent | AudioContent\n    model: str\n    \"\"\"The name of the model that generated the message.\"\"\"\n    stopReason: StopReason | None = None\n    \"\"\"The reason why sampling stopped, if known.\"\"\"\n</code></pre>"},{"location":"api/#mcp.CreateMessageResult.model","title":"model  <code>instance-attribute</code>","text":"<pre><code>model: str\n</code></pre> <p>The name of the model that generated the message.</p>"},{"location":"api/#mcp.CreateMessageResult.stopReason","title":"stopReason  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>stopReason: StopReason | None = None\n</code></pre> <p>The reason why sampling stopped, if known.</p>"},{"location":"api/#mcp.ErrorData","title":"ErrorData","text":"<p>               Bases: <code>BaseModel</code></p> <p>Error information for JSON-RPC error responses.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ErrorData(BaseModel):\n    \"\"\"Error information for JSON-RPC error responses.\"\"\"\n\n    code: int\n    \"\"\"The error type that occurred.\"\"\"\n\n    message: str\n    \"\"\"\n    A short description of the error. The message SHOULD be limited to a concise single\n    sentence.\n    \"\"\"\n\n    data: Any | None = None\n    \"\"\"\n    Additional information about the error. The value of this member is defined by the\n    sender (e.g. detailed error information, nested errors etc.).\n    \"\"\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ErrorData.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: int\n</code></pre> <p>The error type that occurred.</p>"},{"location":"api/#mcp.ErrorData.message","title":"message  <code>instance-attribute</code>","text":"<pre><code>message: str\n</code></pre> <p>A short description of the error. The message SHOULD be limited to a concise single sentence.</p>"},{"location":"api/#mcp.ErrorData.data","title":"data  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>data: Any | None = None\n</code></pre> <p>Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).</p>"},{"location":"api/#mcp.GetPromptRequest","title":"GetPromptRequest","text":"<p>               Bases: <code>Request[GetPromptRequestParams, Literal['prompts/get']]</code></p> <p>Used by the client to get a prompt provided by the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptRequest(Request[GetPromptRequestParams, Literal[\"prompts/get\"]]):\n    \"\"\"Used by the client to get a prompt provided by the server.\"\"\"\n\n    method: Literal[\"prompts/get\"] = \"prompts/get\"\n    params: GetPromptRequestParams\n</code></pre>"},{"location":"api/#mcp.GetPromptResult","title":"GetPromptResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a prompts/get request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class GetPromptResult(Result):\n    \"\"\"The server's response to a prompts/get request from the client.\"\"\"\n\n    description: str | None = None\n    \"\"\"An optional description for the prompt.\"\"\"\n    messages: list[PromptMessage]\n</code></pre>"},{"location":"api/#mcp.GetPromptResult.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>An optional description for the prompt.</p>"},{"location":"api/#mcp.Implementation","title":"Implementation","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Describes the name and version of an MCP implementation.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Implementation(BaseMetadata):\n    \"\"\"Describes the name and version of an MCP implementation.\"\"\"\n\n    version: str\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.InitializedNotification","title":"InitializedNotification","text":"<p>               Bases: <code>Notification[NotificationParams | None, Literal['notifications/initialized']]</code></p> <p>This notification is sent from the client to the server after initialization has finished.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializedNotification(Notification[NotificationParams | None, Literal[\"notifications/initialized\"]]):\n    \"\"\"\n    This notification is sent from the client to the server after initialization has\n    finished.\n    \"\"\"\n\n    method: Literal[\"notifications/initialized\"] = \"notifications/initialized\"\n    params: NotificationParams | None = None\n</code></pre>"},{"location":"api/#mcp.InitializeRequest","title":"InitializeRequest","text":"<p>               Bases: <code>Request[InitializeRequestParams, Literal['initialize']]</code></p> <p>This request is sent from the client to the server when it first connects, asking it to begin initialization.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeRequest(Request[InitializeRequestParams, Literal[\"initialize\"]]):\n    \"\"\"\n    This request is sent from the client to the server when it first connects, asking it\n    to begin initialization.\n    \"\"\"\n\n    method: Literal[\"initialize\"] = \"initialize\"\n    params: InitializeRequestParams\n</code></pre>"},{"location":"api/#mcp.InitializeResult","title":"InitializeResult","text":"<p>               Bases: <code>Result</code></p> <p>After receiving an initialize request from the client, the server sends this.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class InitializeResult(Result):\n    \"\"\"After receiving an initialize request from the client, the server sends this.\"\"\"\n\n    protocolVersion: str | int\n    \"\"\"The version of the Model Context Protocol that the server wants to use.\"\"\"\n    capabilities: ServerCapabilities\n    serverInfo: Implementation\n    instructions: str | None = None\n    \"\"\"Instructions describing how to use the server and its features.\"\"\"\n</code></pre>"},{"location":"api/#mcp.InitializeResult.protocolVersion","title":"protocolVersion  <code>instance-attribute</code>","text":"<pre><code>protocolVersion: str | int\n</code></pre> <p>The version of the Model Context Protocol that the server wants to use.</p>"},{"location":"api/#mcp.InitializeResult.instructions","title":"instructions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>instructions: str | None = None\n</code></pre> <p>Instructions describing how to use the server and its features.</p>"},{"location":"api/#mcp.JSONRPCError","title":"JSONRPCError","text":"<p>               Bases: <code>BaseModel</code></p> <p>A response to a request that indicates an error occurred.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCError(BaseModel):\n    \"\"\"A response to a request that indicates an error occurred.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: str | int\n    error: ErrorData\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.JSONRPCRequest","title":"JSONRPCRequest","text":"<p>               Bases: <code>Request[dict[str, Any] | None, str]</code></p> <p>A request that expects a response.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCRequest(Request[dict[str, Any] | None, str]):\n    \"\"\"A request that expects a response.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    method: str\n    params: dict[str, Any] | None = None\n</code></pre>"},{"location":"api/#mcp.JSONRPCResponse","title":"JSONRPCResponse","text":"<p>               Bases: <code>BaseModel</code></p> <p>A successful (non-error) response to a request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class JSONRPCResponse(BaseModel):\n    \"\"\"A successful (non-error) response to a request.\"\"\"\n\n    jsonrpc: Literal[\"2.0\"]\n    id: RequestId\n    result: dict[str, Any]\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ListPromptsRequest","title":"ListPromptsRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['prompts/list']]</code></p> <p>Sent from the client to request a list of prompts and prompt templates.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsRequest(PaginatedRequest[Literal[\"prompts/list\"]]):\n    \"\"\"Sent from the client to request a list of prompts and prompt templates.\"\"\"\n\n    method: Literal[\"prompts/list\"] = \"prompts/list\"\n</code></pre>"},{"location":"api/#mcp.ListPromptsResult","title":"ListPromptsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a prompts/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListPromptsResult(PaginatedResult):\n    \"\"\"The server's response to a prompts/list request from the client.\"\"\"\n\n    prompts: list[Prompt]\n</code></pre>"},{"location":"api/#mcp.ListResourcesRequest","title":"ListResourcesRequest","text":"<p>               Bases: <code>PaginatedRequest[Literal['resources/list']]</code></p> <p>Sent from the client to request a list of resources the server has.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesRequest(PaginatedRequest[Literal[\"resources/list\"]]):\n    \"\"\"Sent from the client to request a list of resources the server has.\"\"\"\n\n    method: Literal[\"resources/list\"] = \"resources/list\"\n</code></pre>"},{"location":"api/#mcp.ListResourcesResult","title":"ListResourcesResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a resources/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListResourcesResult(PaginatedResult):\n    \"\"\"The server's response to a resources/list request from the client.\"\"\"\n\n    resources: list[Resource]\n</code></pre>"},{"location":"api/#mcp.ListToolsResult","title":"ListToolsResult","text":"<p>               Bases: <code>PaginatedResult</code></p> <p>The server's response to a tools/list request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ListToolsResult(PaginatedResult):\n    \"\"\"The server's response to a tools/list request from the client.\"\"\"\n\n    tools: list[Tool]\n</code></pre>"},{"location":"api/#mcp.LoggingMessageNotification","title":"LoggingMessageNotification","text":"<p>               Bases: <code>Notification[LoggingMessageNotificationParams, Literal['notifications/message']]</code></p> <p>Notification of a log message passed from server to client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class LoggingMessageNotification(Notification[LoggingMessageNotificationParams, Literal[\"notifications/message\"]]):\n    \"\"\"Notification of a log message passed from server to client.\"\"\"\n\n    method: Literal[\"notifications/message\"] = \"notifications/message\"\n    params: LoggingMessageNotificationParams\n</code></pre>"},{"location":"api/#mcp.Notification","title":"Notification","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[NotificationParamsT, MethodT]</code></p> <p>Base class for JSON-RPC notifications.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Notification(BaseModel, Generic[NotificationParamsT, MethodT]):\n    \"\"\"Base class for JSON-RPC notifications.\"\"\"\n\n    method: MethodT\n    params: NotificationParamsT\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PingRequest","title":"PingRequest","text":"<p>               Bases: <code>Request[RequestParams | None, Literal['ping']]</code></p> <p>A ping, issued by either the server or the client, to check that the other party is still alive.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PingRequest(Request[RequestParams | None, Literal[\"ping\"]]):\n    \"\"\"\n    A ping, issued by either the server or the client, to check that the other party is\n    still alive.\n    \"\"\"\n\n    method: Literal[\"ping\"] = \"ping\"\n    params: RequestParams | None = None\n</code></pre>"},{"location":"api/#mcp.ProgressNotification","title":"ProgressNotification","text":"<p>               Bases: <code>Notification[ProgressNotificationParams, Literal['notifications/progress']]</code></p> <p>An out-of-band notification used to inform the receiver of a progress update for a long-running request.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ProgressNotification(Notification[ProgressNotificationParams, Literal[\"notifications/progress\"]]):\n    \"\"\"\n    An out-of-band notification used to inform the receiver of a progress update for a\n    long-running request.\n    \"\"\"\n\n    method: Literal[\"notifications/progress\"] = \"notifications/progress\"\n    params: ProgressNotificationParams\n</code></pre>"},{"location":"api/#mcp.PromptsCapability","title":"PromptsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for prompts operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class PromptsCapability(BaseModel):\n    \"\"\"Capability for prompts operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the prompt list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.PromptsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the prompt list.</p>"},{"location":"api/#mcp.ReadResourceRequest","title":"ReadResourceRequest","text":"<p>               Bases: <code>Request[ReadResourceRequestParams, Literal['resources/read']]</code></p> <p>Sent from the client to the server, to read a specific resource URI.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceRequest(Request[ReadResourceRequestParams, Literal[\"resources/read\"]]):\n    \"\"\"Sent from the client to the server, to read a specific resource URI.\"\"\"\n\n    method: Literal[\"resources/read\"] = \"resources/read\"\n    params: ReadResourceRequestParams\n</code></pre>"},{"location":"api/#mcp.ReadResourceResult","title":"ReadResourceResult","text":"<p>               Bases: <code>Result</code></p> <p>The server's response to a resources/read request from the client.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ReadResourceResult(Result):\n    \"\"\"The server's response to a resources/read request from the client.\"\"\"\n\n    contents: list[TextResourceContents | BlobResourceContents]\n</code></pre>"},{"location":"api/#mcp.Resource","title":"Resource","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>A known resource that the server is capable of reading.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Resource(BaseMetadata):\n    \"\"\"A known resource that the server is capable of reading.\"\"\"\n\n    uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n    \"\"\"The URI of this resource.\"\"\"\n    description: str | None = None\n    \"\"\"A description of what this resource represents.\"\"\"\n    mimeType: str | None = None\n    \"\"\"The MIME type of this resource, if known.\"\"\"\n    size: int | None = None\n    \"\"\"\n    The size of the raw resource content, in bytes (i.e., before base64 encoding\n    or any tokenization), if known.\n\n    This can be used by Hosts to display file sizes and estimate context window usage.\n    \"\"\"\n    annotations: Annotations | None = None\n    meta: dict[str, Any] | None = Field(alias=\"_meta\", default=None)\n    \"\"\"\n    See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n    for notes on _meta usage.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Resource.uri","title":"uri  <code>instance-attribute</code>","text":"<pre><code>uri: Annotated[AnyUrl, UrlConstraints(host_required=False)]\n</code></pre> <p>The URI of this resource.</p>"},{"location":"api/#mcp.Resource.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A description of what this resource represents.</p>"},{"location":"api/#mcp.Resource.mimeType","title":"mimeType  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mimeType: str | None = None\n</code></pre> <p>The MIME type of this resource, if known.</p>"},{"location":"api/#mcp.Resource.size","title":"size  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>size: int | None = None\n</code></pre> <p>The size of the raw resource content, in bytes (i.e., before base64 encoding or any tokenization), if known.</p> <p>This can be used by Hosts to display file sizes and estimate context window usage.</p>"},{"location":"api/#mcp.Resource.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"api/#mcp.ResourcesCapability","title":"ResourcesCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for resources operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourcesCapability(BaseModel):\n    \"\"\"Capability for resources operations.\"\"\"\n\n    subscribe: bool | None = None\n    \"\"\"Whether this server supports subscribing to resource updates.\"\"\"\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the resource list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ResourcesCapability.subscribe","title":"subscribe  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subscribe: bool | None = None\n</code></pre> <p>Whether this server supports subscribing to resource updates.</p>"},{"location":"api/#mcp.ResourcesCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the resource list.</p>"},{"location":"api/#mcp.ResourceUpdatedNotification","title":"ResourceUpdatedNotification","text":"<p>               Bases: <code>Notification[ResourceUpdatedNotificationParams, Literal['notifications/resources/updated']]</code></p> <p>A notification from the server to the client, informing it that a resource has changed and may need to be read again.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ResourceUpdatedNotification(\n    Notification[ResourceUpdatedNotificationParams, Literal[\"notifications/resources/updated\"]]\n):\n    \"\"\"\n    A notification from the server to the client, informing it that a resource has\n    changed and may need to be read again.\n    \"\"\"\n\n    method: Literal[\"notifications/resources/updated\"] = \"notifications/resources/updated\"\n    params: ResourceUpdatedNotificationParams\n</code></pre>"},{"location":"api/#mcp.RootsCapability","title":"RootsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for root operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class RootsCapability(BaseModel):\n    \"\"\"Capability for root operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether the client supports notifications for changes to the roots list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.RootsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether the client supports notifications for changes to the roots list.</p>"},{"location":"api/#mcp.SamplingMessage","title":"SamplingMessage","text":"<p>               Bases: <code>BaseModel</code></p> <p>Describes a message issued to or received from an LLM API.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SamplingMessage(BaseModel):\n    \"\"\"Describes a message issued to or received from an LLM API.\"\"\"\n\n    role: Role\n    content: TextContent | ImageContent | AudioContent\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities","title":"ServerCapabilities","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capabilities that a server may support.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ServerCapabilities(BaseModel):\n    \"\"\"Capabilities that a server may support.\"\"\"\n\n    experimental: dict[str, dict[str, Any]] | None = None\n    \"\"\"Experimental, non-standard capabilities that the server supports.\"\"\"\n    logging: LoggingCapability | None = None\n    \"\"\"Present if the server supports sending log messages to the client.\"\"\"\n    prompts: PromptsCapability | None = None\n    \"\"\"Present if the server offers any prompt templates.\"\"\"\n    resources: ResourcesCapability | None = None\n    \"\"\"Present if the server offers any resources to read.\"\"\"\n    tools: ToolsCapability | None = None\n    \"\"\"Present if the server offers any tools to call.\"\"\"\n    completions: CompletionsCapability | None = None\n    \"\"\"Present if the server offers autocompletion suggestions for prompts and resources.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ServerCapabilities.experimental","title":"experimental  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>experimental: dict[str, dict[str, Any]] | None = None\n</code></pre> <p>Experimental, non-standard capabilities that the server supports.</p>"},{"location":"api/#mcp.ServerCapabilities.logging","title":"logging  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>logging: LoggingCapability | None = None\n</code></pre> <p>Present if the server supports sending log messages to the client.</p>"},{"location":"api/#mcp.ServerCapabilities.prompts","title":"prompts  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>prompts: PromptsCapability | None = None\n</code></pre> <p>Present if the server offers any prompt templates.</p>"},{"location":"api/#mcp.ServerCapabilities.resources","title":"resources  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>resources: ResourcesCapability | None = None\n</code></pre> <p>Present if the server offers any resources to read.</p>"},{"location":"api/#mcp.ServerCapabilities.tools","title":"tools  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>tools: ToolsCapability | None = None\n</code></pre> <p>Present if the server offers any tools to call.</p>"},{"location":"api/#mcp.ServerCapabilities.completions","title":"completions  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>completions: CompletionsCapability | None = None\n</code></pre> <p>Present if the server offers autocompletion suggestions for prompts and resources.</p>"},{"location":"api/#mcp.SetLevelRequest","title":"SetLevelRequest","text":"<p>               Bases: <code>Request[SetLevelRequestParams, Literal['logging/setLevel']]</code></p> <p>A request from the client to the server, to enable or adjust logging.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SetLevelRequest(Request[SetLevelRequestParams, Literal[\"logging/setLevel\"]]):\n    \"\"\"A request from the client to the server, to enable or adjust logging.\"\"\"\n\n    method: Literal[\"logging/setLevel\"] = \"logging/setLevel\"\n    params: SetLevelRequestParams\n</code></pre>"},{"location":"api/#mcp.SubscribeRequest","title":"SubscribeRequest","text":"<p>               Bases: <code>Request[SubscribeRequestParams, Literal['resources/subscribe']]</code></p> <p>Sent from the client to request resources/updated notifications from the server whenever a particular resource changes.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class SubscribeRequest(Request[SubscribeRequestParams, Literal[\"resources/subscribe\"]]):\n    \"\"\"\n    Sent from the client to request resources/updated notifications from the server\n    whenever a particular resource changes.\n    \"\"\"\n\n    method: Literal[\"resources/subscribe\"] = \"resources/subscribe\"\n    params: SubscribeRequestParams\n</code></pre>"},{"location":"api/#mcp.Tool","title":"Tool","text":"<p>               Bases: <code>BaseMetadata</code></p> <p>Definition for a tool the client can call.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class Tool(BaseMetadata):\n    \"\"\"Definition for a tool the client can call.\"\"\"\n\n    description: str | None = None\n    \"\"\"A human-readable description of the tool.\"\"\"\n    inputSchema: dict[str, Any]\n    \"\"\"A JSON Schema object defining the expected parameters for the tool.\"\"\"\n    outputSchema: dict[str, Any] | None = None\n    \"\"\"\n    An optional JSON Schema object defining the structure of the tool's output\n    returned in the structuredContent field of a CallToolResult.\n    \"\"\"\n    annotations: ToolAnnotations | None = None\n    \"\"\"Optional additional tool information.\"\"\"\n    meta: dict[str, Any] | None = Field(alias=\"_meta\", default=None)\n    \"\"\"\n    See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)\n    for notes on _meta usage.\n    \"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.Tool.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description: str | None = None\n</code></pre> <p>A human-readable description of the tool.</p>"},{"location":"api/#mcp.Tool.inputSchema","title":"inputSchema  <code>instance-attribute</code>","text":"<pre><code>inputSchema: dict[str, Any]\n</code></pre> <p>A JSON Schema object defining the expected parameters for the tool.</p>"},{"location":"api/#mcp.Tool.outputSchema","title":"outputSchema  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>outputSchema: dict[str, Any] | None = None\n</code></pre> <p>An optional JSON Schema object defining the structure of the tool's output returned in the structuredContent field of a CallToolResult.</p>"},{"location":"api/#mcp.Tool.annotations","title":"annotations  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>annotations: ToolAnnotations | None = None\n</code></pre> <p>Optional additional tool information.</p>"},{"location":"api/#mcp.Tool.meta","title":"meta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>meta: dict[str, Any] | None = Field(\n    alias=\"_meta\", default=None\n)\n</code></pre> <p>See MCP specification for notes on _meta usage.</p>"},{"location":"api/#mcp.ToolsCapability","title":"ToolsCapability","text":"<p>               Bases: <code>BaseModel</code></p> <p>Capability for tools operations.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class ToolsCapability(BaseModel):\n    \"\"\"Capability for tools operations.\"\"\"\n\n    listChanged: bool | None = None\n    \"\"\"Whether this server supports notifications for changes to the tool list.\"\"\"\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/#mcp.ToolsCapability.listChanged","title":"listChanged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>listChanged: bool | None = None\n</code></pre> <p>Whether this server supports notifications for changes to the tool list.</p>"},{"location":"api/#mcp.UnsubscribeRequest","title":"UnsubscribeRequest","text":"<p>               Bases: <code>Request[UnsubscribeRequestParams, Literal['resources/unsubscribe']]</code></p> <p>Sent from the client to request cancellation of resources/updated notifications from the server.</p> Source code in <code>src/mcp/types.py</code> <pre><code>class UnsubscribeRequest(Request[UnsubscribeRequestParams, Literal[\"resources/unsubscribe\"]]):\n    \"\"\"\n    Sent from the client to request cancellation of resources/updated notifications from\n    the server.\n    \"\"\"\n\n    method: Literal[\"resources/unsubscribe\"] = \"resources/unsubscribe\"\n    params: UnsubscribeRequestParams\n</code></pre>"}]}